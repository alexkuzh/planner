# ARCHITECTURE.md (v3)

## 1. Назначение системы

**Planner** — backend-система для управления производственными задачами с чёткой
доменной моделью, основанной на:

- конечных автоматах (FSM),
- строгой идемпотентности,
- оптимистической блокировке,
- разделении ответственности между доменами.

Ключевая цель архитектуры — **предсказуемость процессов**, **аудируемость**
и **устойчивость к ошибкам клиента** (повторы запросов, гонки, ретраи).

---

## 2. Доменные границы (Domain Boundaries)

### 2.1 Task — основной домен

**Task** — атомарная единица работы.

Свойства:
- принадлежит `org_id` и `project_id`,
- имеет статус (`status`) и версию (`row_version`),
- может быть связана с `deliverable`,
- изменяется **только** через FSM.

Запрещено:
- менять `status` напрямую через `PATCH`,
- создавать побочные эффекты вне FSM.

Все изменения статуса происходят через:

POST /tasks/{task_id}/transitions

---

### 2.2 Task FSM (Finite State Machine)

FSM определяет допустимые переходы статусов задачи.

#### Статусы

- new
- planned
- assigned
- in_progress
- in_review
- rejected
- done
- canceled


#### Основные действия

- plan
- assign
- unassign
- start
- submit
- approve
- reject


FSM:
- **не знает ролей**,
- **не знает API**,
- **не знает БД**,
- возвращает только `(to_status, side_effects)`.

---

### 2.3 TaskTransition — журнал переходов

`TaskTransition` — **неизменяемый лог** всех FSM-переходов.

Назначение:
- аудит,
- восстановление истории,
- строгая идемпотентность,
- защита от race conditions.

Ключевые поля:
- `client_event_id` — ключ идемпотентности,
- `expected_row_version`,
- `result_row_version`,
- `payload` (нормализованный).

Правило:
> Если `client_event_id` уже использован — запрос либо повторяется,
> либо отклоняется как конфликт.

---

### 2.4 Fix-task (исправление дефектов)

**Fix-task** — отдельная задача, создаваемая при обнаружении дефекта.

Создание:
- автоматически как side-effect FSM-действия `reject`,
- вручную через worker initiative (`/report-fix`).

Свойства:
- всегда привязана к `deliverable`,
- не «возвращает» основную задачу автоматически,
- проходит **тот же FSM**, что и обычные задачи.

Fix-task — **не поддомен Task**, а отдельный бизнес-сценарий поверх него.

---

### 2.5 QC (Quality Control) — отдельный домен

QC **не является частью Task FSM**.

Принцип (Variant A, зафиксирован):
- QC **не переводит Task по статусам**,
- QC работает через `deliverable` и `qc_inspections`,
- результаты QC могут **инициировать** создание fix-task,
  но не управляют Task напрямую.

### Любые действия вида: qc_*
запрещены в `/tasks/{id}/transitions`.

---

## 3. Роли и RBAC

RBAC проверяется **на уровне API**, а не FSM.

FSM:
- не знает ролей,
- не принимает решений о доступе.

RBAC:
- сопоставляет `role → permission`,
- разрешения привязаны к действиям (`task.plan`, `task.assign`, и т.д.).

Пример:

task.plan → system, lead

task.assign → lead, supervisor

task.approve → lead, supervisor

fix.qc_reject → qc


---

## 4. Идемпотентность

Каждый mutating-запрос может содержать `client_event_id`.

Поведение:
- тот же `client_event_id` + тот же смысл → safe retry,
- тот же `client_event_id` + другие данные → `409 Conflict`.

Для сравнения:
- payload нормализуется,
- серверные поля (например `fix_task_id`) игнорируются.

---

## 5. Оптимистическая блокировка

Используется `row_version`.

Правило:
- клиент обязан передать `expected_row_version`,
- если версия не совпадает — `409 Conflict`.

Это:
- защищает от lost update,
- не требует `SELECT ... FOR UPDATE`,
- хорошо масштабируется.

---

## 6. API — ответственность эндпоинтов

### 6.1 /tasks

- `POST /tasks` — создание задачи,
- `PATCH /tasks/{id}` — изменение метаданных (НЕ статус),
- `DELETE /tasks/{id}` — удаление (RBAC + guard).

### 6.2 /tasks/{id}/transitions

Единственный способ:
- менять статус,
- создавать fix-task,
- фиксировать историю.

### 6.3 /tasks/{id}/report-fix

Worker-initiative сценарий:
- фиксация дефекта,
- создание новой fix-task,
- без влияния на FSM исходной задачи.

---

## 7. Архитектурные принципы

1. **FSM — чистая логика**
2. **API — только оркестрация**
3. **Сервисы — бизнес-правила**
4. **TaskTransition — источник истины**
5. **QC отделён от Task**
6. **Идемпотентность обязательна**
7. **Один запрос — одно намерение**

---

## 8. Зафиксированные решения (v3)

- QC не управляет Task напрямую
- status нельзя менять через update
- все переходы только через FSM
- fix-task — отдельный сценарий
- idempotency строгая
- row_version обязателен

---

## 9. Что дальше (v4+)

- QC milestones
- Deliverable lifecycle
- Read-models (CQRS)
- UI/CLI сценарии
- Event streaming (опционально)

---

**ARCHITECTURE.md v3 зафиксирован.**

# UPDATE
# Task Execution Architecture
## Pool-based Assignment · Shift Ownership · Skill-gated Responsibility

---

## 1. Core execution model

Система использует **pull-модель выполнения задач**, управляемую сменами и ролями:

- задачи попадают в **пул доступных задач** (`available`)
- исполнитель **выбирает задачу** и становится её **primary executor (owner)**
- над задачей могут работать **несколько исполнителей** (contributors)
- только **owner** управляет жизненным циклом задачи (start/submit)
- лидер и супервайзер сохраняют **полный контроль**: назначение, отзыв, переназначение, контроль качества

Назначение задачи всегда **временно** и ограничено **сменой**.

---

## 2. Roles

- **executor** — выполняет работу, может быть owner или contributor  
- **lead / supervisor** — управляет распределением, проверкой, фиксацией дефектов  
- **system** — выполняет автоматические переходы (например, окончание смены)

---

## 3. Specialization (trade)

### Executor
Исполнитель может иметь **несколько специализаций**:

```
specializations: Set[Trade]
```

Специализация используется для:
- видимости пула задач
- возможности стать primary executor

### Task
Задача может требовать одну специализацию:

```
required_trade: Trade | null
```

**Правило соответствия:**  
executor может взять задачу, если  
`required_trade is null OR required_trade ∈ executor.specializations`

---

## 4. Skill model (trust & autonomy)

### Skill level
```
skill_level: int (1–10)
```

Skill отражает **уровень доверия**, а не допуск к работе.

Skill **НЕ влияет** на:
- видимость пула
- возможность присоединиться к задаче (contributor)

Skill **влияет** на:
- возможность стать primary executor (self-assign)
- возможность самопроверки (self-QC)

### Global thresholds
- `MIN_SKILL_TO_TAKE` — минимальный skill, чтобы **выбрать задачу**
- `SELF_CHECK_MIN_SKILL` — минимальный skill для **самопроверки без лида**

---

## 5. Task participation model

### Primary executor (owner)
- всегда **один**
- выбирает задачу из пула или назначается лидом
- управляет статусом выполнения
- делает submit
- может выполнять self-QC (если позволяет skill)

### Contributors
- 0..N исполнителей
- помогают в выполнении
- **не могут** менять статус задачи
- могут быть добавлены/удалены лидом
- могут покинуть задачу

---

## 6. Work-in-Progress constraints

- **Owner WIP = 1**  
  Исполнитель может быть primary executor **только одной активной задачи**.

---

## 7. Task pool (`available`)

Задача находится в пуле, если:
- не назначен primary executor
- выполнены зависимости
- нет блокировок
- задача не завершена

### Видимость пула
- **lead/supervisor** — видят весь пул
- **executor**:
  - если `skill < MIN_SKILL_TO_TAKE` → пул **не видит**
  - иначе видит пул **только по своим специализациям**

---

## 8. FSM rules (high-level)

### Назначение
- `available → assigned`
  - `self_assign` (executor)
  - `assign` (lead/supervisor)

### Выполнение
- `assigned → in_progress`
- `in_progress → submitted`

### Контроль качества
- `submitted → done` — self-QC
- `submitted → done` — QC approve
- `submitted → in_progress` — QC reject

---

## 9. Возврат в пул

Из `in_progress` задача возвращается в пул **только**:
- по окончании смены (`shift_release`)
- по отзыву лидом (`recall_to_pool`)

---

## 10. Shift semantics

- Назначение действует **только в рамках смены**
- В конце смены система:
  - снимает owner
  - завершает contributors
  - возвращает задачу в пул

---

## 11. Fix flow

- Fix создаётся **только после submit/done**
- Инициируется **lead/supervisor**
- Fix — отдельная задача, связанная с оригинальной

---

## 12. Defects

Для каждого фикса фиксируется дефект:
- причина
- что исправить
- как исправлено
- кто и когда

Формируется **база ошибок**.

---

## 13. Task catalog & tree

### TaskTemplate
- иерархия операций
- регламенты
- материалы и инструменты

### Task
- экземпляр выполнения
- ссылка на template

---

## 14. Recommendations (future)

Рекомендации строятся на основе:
- дерева операций
- истории дефектов
- пересечений по материалам и инструментам

---

## 15. Design principles

- Один owner — много contributors
- Skill = доверие
- Специализация = поток работ
- Пул — только выполнимые задачи
- Возврат в пул — контролируемый
- Исключения лидом — аудируемые
