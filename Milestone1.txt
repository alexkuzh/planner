Большой срез состояния проекта (на 2026-01-11)
0) Цель проекта в одном абзаце

Строим систему управления производственным процессом “по шаблону”: проект создаётся по шаблону задач (дерево / граф), после чего задачи существуют сразу все, но выполняются в зависимости от dependencies. По сути: “пришёл пустой ящик → запускается процесс → внутри уже задана ДНК изделия (шаблон) → задача за задачей доводим до результата”. Система должна быть:

корректной по состояниям (FSM),

устойчивой к гонкам (optimistic lock + идемпотентность),

наблюдаемой (логирование событий / transitions),

расширяемой (QC, allocation, deliverables, sign-off),

и с хорошим API, удобным для автоматизированных прогонов (Postman/Newman).

1) Концептуальная модель предметной области
1.1 Проект и шаблон

Один проект создаётся по одному шаблону.

У шаблонов есть версии, которые могут меняться, но конкретный проект “прилипает” к конкретной версии шаблона.

1.2 Дерево задач и зависимости

При старте проекта создаются все задачи по шаблону сразу.

Но не все можно делать сразу: есть зависимости (blockers).

Визуально / логически: задача имеет список “что должно быть done”, прежде чем она будет “разблокирована”.

1.3 QC (контроль качества)

В модели присутствует QC-контур (инспекции/проверки).

Есть сценарии “reject/accept” (или “qc reject flow”) и последствия на задачах (возврат/переоткрытие/перевод в нужный статус).

1.4 Allocation / Assignment

Есть распределение задач: назначение исполнителя (assign_to), фиксация assigned_at.

Назначение — это не “просто update поля”, а действие FSM со своей валидацией.

2) Архитектура и структура кода (что реально уже есть)
2.1 Основные модули (по файлам)

По текущему дереву:

core/

core/db.py — подключение/сессии/engine

core/config.py — конфигурация

models/

task.py, task_event.py, task_transition.py — базовая модель задач + события + переходы

deliverable.py, deliverable_signoff.py — результат/изделие и sign-off

qc_inspection.py — QC сущность

task_allocation.py — распределение/назначение

base.py — базовый класс моделей

fsm/

task_fsm.py — правила переходов и валидации действий

schemas/

pydantic-схемы для API: task.py, transition.py, qc_inspection.py, deliverable_*

services/

task_transition_service.py — применение action → FSM → запись события → обновление task

task_allocation_service.py — отдельные операции по allocation/assignment

deliverable_bootstrap_service.py — создание задач/структуры при старте проекта/деливерабла

task_fix_service.py — фиксы/миграции/устранение inconsistencies (служебное)

api/

tasks.py, deliverables.py, allocations.py, health.py, deps.py

main.py — сборка FastAPI приложения

2.2 Ключевой принцип: “FSM — единственный источник истины”

Мы сознательно пришли к выводу:

руками менять статус в базе нельзя, т.к. ломаются инварианты (blockers/derived состояния/события).

изменения задач — только через сервис, который:

валидирует действие через FSM,

проверяет expected_row_version,

пишет event/transition,

обновляет текущую задачу.

3) Модель задач: важные поля и смысл

По таблице tasks (что уже подсмотрено в БД):

id uuid

org_id, project_id, deliverable_id — сквозные контексты

title, description

status — текущее состояние

priority (default 0)

kind, other_kind_label — тип задачи

work_kind enum (work по умолчанию)

is_milestone boolean

created_by

assigned_to, assigned_at

expected_row_version/row_version (по смыслу) — optimistic lock (мы это используем в API)

и др.

Критически важно:

status должен менять только FSM/transition сервис.

блокировки и зависимости должны вычисляться согласованно с task_events / task_transitions (если они ведутся как аудит).

4) API: что уже сделано и где споткнулись
4.1 Эндпоинты (фактически)

Есть api/tasks.py (и другие), которые:

создают/читают задачи,

возвращают дашборд deliverable,

принимают действия “action” над задачей.

4.2 Transition endpoint и payload

Был конкретный кейс:

Пользователь пытался сделать action = "assign" через Swagger, но получил Unprocessable Content:

"Action 'assign' требует payload.assign_to (user_id)."

Это правильно: assign — это действие, требующее payload.

4.3 Проблема Swagger / OpenAPI примеров

Пользовательский pain:

Swagger показывает абстрактный additionalProp1, не раскрывает реальные примеры payload.

Нужно сделать так, чтобы в Swagger были чёткие примеры для разных действий (assign/reject/etc).

Это прямо зафиксировано как задача:

“Сделай, чтобы в Swagger в payload показывались нормальные примеры для assign/reject”.

5) Инварианты и корректность: что уже осознано
5.1 Почему нельзя “править в БД руками”

Был реальный эпизод:

статус задачи руками поставили в done,

blockers “как будто” исчезли,

но стало понятно, что это иллюзия, потому что:

события не записаны,

версионирование не соблюдено,

зависимости/derived поля могут стать несогласованными.

Вывод зафиксирован:

никаких ручных апдейтов статусов.

только через API + FSM.

5.2 Идемпотентность

В API присутствует client_event_id.
Логика: повторный запрос с тем же client_event_id не должен “переисполнить” действие (или должен возвращать тот же результат безопасно).

5.3 Optimistic Lock

В API есть expected_row_version.
Смысл: защита от гонок (две операции над одной задачей).
Это часть “правильной” модели конкурентности.

6) DB / производительность: что уже было начато
6.1 pg_stat_statements включен

Проверяли:

shared_preload_libraries содержит pg_stat_statements.

extension создана.

reset делали.

6.2 Логика: нагрузка не “абстрактная”, а из Postman/Newman

Идея: не “приближать нагрузку синтетикой”, а запускать реальные запросы к API:

Postman коллекция — основной сценарий,

Newman — runner для повторов/итераций,

потом смотреть pg_stat_statements, и только после этого:

индексы,

переписывание запросов,

оптимизация.

6.3 Важное: имеет ли смысл профилировать на локалке?

Поднимался вопрос: “есть ли смысл смотреть нагрузку, если всё локально и быстро?”
Ответ (по сути): смысл есть, потому что:

локальная среда всё равно показывает:

структуру запросов,

частоту,

лишние round-trip’ы,

N+1,

отсутствие индексов (по плану),

неоптимальные фильтры/joins.
Но абсолютные миллисекунды локально не равны продовым — это нормально.

7) Тестирование: что запланировано (и частично уже обсуждено)

Список блоков, которые мы вынесли как “независимые темы”:

Тесты: FSM, invariants, qc reject flow, idempotency

DB constraints / partial indexes — где можно усилить

Auth — уйти от org_id/actor_user_id в body/query к нормальному auth контексту

UI/CLI сценарии — end-to-end проверка

Отдельно проговаривалось правило организации:

один пункт — один чат (в рамках проекта), чтобы не терять фокус и быстрее двигаться.

8) Что именно было “последней точкой”, где остановились

Если коротко:

Всё запускается через make (окружение поднято).

Мы дошли до UX-проблемы в Swagger:

payload примеры не показываются,

пользователь не понимает, какие поля нужны для assign/reject.

Параллельно стартовали тему Postman/Newman:

хочется не руками дергать API,

а иметь коллекцию и гонять сценарии.

Начали трогать pg_stat_statements и убедились, что оно включено.

Был эпизод с ручным done в БД → осознали, что это ломает модель → закрепили как запрет.

9) Текущее состояние “как система должна работать” (операционный сценарий)
9.1 Happy path (упрощённо)

Создаётся deliverable/project → bootstrap создаёт задачи по шаблону.

Задачи видны, но часть “заблокирована” зависимостями.

Пользователь:

назначает исполнителя (assign),

переводит по FSM (start/progress/done),

QC может принимать/отклонять.

Каждое действие:

проходит через FSM валидацию,

фиксируется событием,

защищено expected_row_version,

идемпотентно по client_event_id.

UI/дашборды показывают:

текущие статусы,

blockers,

прогресс deliverable.

10) Дальнейшие планы (подробно, по шагам)

Ниже — план, который логично “дожимает” систему до удобного MVP и даёт основу для дальнейшего роста.

План A: привести Swagger/OpenAPI в “самодокументируемый” вид (ближайшая цель)

Зачем: чтобы можно было тестировать API без гадания.

Для endpoint “task transition / action” сделать дискриминированный payload:

action определяет схему payload

в OpenAPI показывать oneOf варианты

Добавить примеры (examples) для каждого action:

assign → { "assign_to": "<uuid>" }

reject → { "reason": "...", "rework_to_status": "..." } (примерный состав)

qc_accept / qc_reject → примеры для QC

start / done → примеры пустых payload или explicit {} если нужно

Валидационные ошибки сделать максимально ясными:

“для action=assign требуется payload.assign_to”

“expected_row_version не совпал”

“task заблокирована зависимостями: …”

Результат: Swagger становится “инструкцией по применению”.

План B: Postman коллекция (минимальный набор) + Newman

Зачем: автоматизировать ручные клики и получить воспроизводимые сценарии.

Создать коллекцию Postman:

Health

Create/Bootstrap deliverable/project (если есть)

List tasks for deliverable/project

Get task details

Transition: assign

Transition: start/progress

Transition: done

QC reject/accept (если готово)

Под переменные окружения:

base_url

org_id

actor_user_id (временно, пока auth не переделан)

project_id / deliverable_id / task_id (цепочкой)

Добавить тест-скрипты Postman:

сохранять ids из response в variables

проверять статус-коды

проверять ключевые поля ответа

Прогон через Newman:

sanity-прогон 1–3 итерации

затем 10–50 итераций для “мини-нагрузки”

План C: Производительность БД (после того как сценарии стабильны)

Зачем: оптимизировать на основании фактов.

Запускаем Newman сценарий

Снимаем pg_stat_statements:

топ по total_time

топ по calls

Находим “главные” запросы

Для каждого:

EXPLAIN (ANALYZE, BUFFERS) на реальных параметрах

решаем: индекс / переписывание / батч / денормализация / кеш

Повторяем цикл

План D: Тесты (FSM, invariants, idempotency)

Зачем: чтобы система не регрессировала.

Unit-тесты FSM:

допустимые переходы

запретные переходы

Инварианты dependencies:

нельзя done, если blockers не закрыты

после закрытия blocker задача “разблокируется” корректно

QC reject flow:

reject возвращает задачу/ветку в нужное состояние

Идемпотентность:

одинаковый client_event_id дважды → один эффект

Optimistic lock:

expected_row_version mismatch → 409/422 (как решено) и без побочных эффектов

План E: Auth (после стабилизации API)

Зачем: убрать “org_id/actor_user_id в body”.

Переход к auth-контексту (например dependency, вытаскивающий actor/org)

В request body остаётся только то, что относится к домену действия

Обновить Postman env соответствующим образом

11) “Что именно нужно перенести в новый чат”

Чтобы новый чат стартовал “с места”, вот рекомендуемый стартовый месседж (копируй как есть):

Сообщение для нового чата:

Мы делаем MVP системы задач по шаблону (проекты создаются по шаблону, задачи создаются все сразу, но исполняются с зависимостями).

Есть FastAPI + SQLAlchemy + Postgres.

Задачи меняют состояние только через FSM + transition service.

Есть optimistic lock через expected_row_version и идемпотентность через client_event_id.

Мы упёрлись в то, что Swagger показывает абстрактный payload (additionalProp1), и непонятно, какие payload нужны для action=assign/reject и других действий.

Хочу: сделать правильные OpenAPI схемы и examples (oneOf/discriminated union) для payload по action, чтобы Swagger был самодостаточен.

Параллельно: делаем Postman коллекцию для сценария (bootstrap → list tasks → assign → progress → done → qc), и потом гоняем Newman и смотрим pg_stat_statements.

12) Риски/узкие места (честный список)

Зависимости/blockers
Самый частый источник багов:

где и как считается “blocked”

что считается “done” для blocker

что делать с “частично выполнено” / “QC вернуло назад”

Смешение “статус в tasks” и “история событий”
Нужно чётко договориться:

status — текущий state

events/transitions — аудит/история/источник восстановления
И обеспечить консистентность.

Swagger/схемы
Если схемы будут абстрактные, никто не сможет пользоваться API правильно.

Auth позже
Пока org_id/actor_user_id в body — допустимо на MVP, но нужно планировать миграцию аккуратно, чтобы не сломать Postman/Newman.

Итог

На текущем этапе у нас уже есть “скелет взрослой системы”:

domain-модель,

FSM,

сервисы переходов,

аудит,

база и инструменты наблюдаемости,

понимание того, что ручные правки в БД ломают инварианты,

и чёткая ближайшая боль: Swagger/OpenAPI примеры и схемы payload.

Если хочешь, я могу сразу следующим шагом (в этом же ответе без кода или с кодом — как скажешь) написать структуру файлов в DOC/, куда лучше разложить этот “срез”, например:

DOC/ARCHITECTURE.md (высокоуровневая модель)

DOC/API.md (эндпоинты + action/payload матрица)

DOC/FSM.md (таблица переходов)

DOC/DB.md (таблицы, индексы, инварианты)

DOC/TEST_PLAN.md (что тестируем)

DOC/PERF.md (Postman/Newman/pg_stat_statements)